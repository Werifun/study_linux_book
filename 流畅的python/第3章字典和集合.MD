# 第 3 章　字典和集合 

- dict 类型不但在各种程序里广泛使用，它也是 Python 语言的基石。 跟它有关的内置函数都在 \_\_builtins\_\_.\_\_dict\_\_模块中。 

## 3.1　泛映射类型 

- instance和type的区别
  - type()不会认为子类是一种父类类型
  - instance会认为子类也是一种父类类型.
- 什么是可散列的数据类型
  - 那么在这个对象的生命周期中，它的**散列值**是不变的 
    - 散列值：eg.Python调用内部的散列函数，字典中的每个key作为输入参数，得到唯一一个值。
  - 这个对象需要实现 \_\_hash\_\_() 方法 
  - 可散列对象还要有 \_\_qe\_\_() 方法，这样才能跟其他键做比较。 

- 可散列的数据类型

  - 原子不可变数据类型（str、 bytes 和数值类型(整型、浮点型、布尔型、)） 

  - frozenset ，因为根据其定义， frozenset里只能容纳可散列类型 
  - 元组的话，只有当一个元组包含的所**有元素都是可散列类型**的情况下，它才是可散列的。 
  - 可以是使用hash()检测一个数据是否可以哈希。
  - 一般来讲用户自定义的类型的对象都是可散列的(???)，散列值就是它们的 id() 函数的返回值 



## 3.2　字典推导 

```python
>>> DIAL_CODES = [ ➊
... 		(86, 'China'),
... 		(91, 'India'),
... 		(1, 'United States'),
... 		(62, 'Indonesia'),
... 		(55, 'Brazil'),
... 		(92, 'Pakistan'),
... 		(880, 'Bangladesh'),
... 		(234, 'Nigeria'),
... 		(7, 'Russia'),
... 		(81, 'Japan'),
... ]
>>> country_code = {country: code for code, country in DIAL_CODES} ➋
>>> country_code
{'China': 86, 'India': 91, 'Bangladesh': 880, 'United States': 1,
'Pakistan': 92, 'Japan': 81, 'Russia': 7, 'Brazil': 55, 'Nigeria':
234, 'Indonesia': 62}
>>> {code: country.upper() for country, code in country_code.items() ➌
... if code < 66}
{1: 'UNITED STATES', 55: 'BRAZIL', 62: 'INDONESIA', 7: 'RUSSIA'}
```



## 3.3　常见的映射方法

- update等方法
- 用setdefault处理找不到的键 
- 文章中的 散射==哈希



## 3.4　映射的弹性键查询 

### 3.4.1 defaultdict：处理找不到的键的一个选择 

- 具体而言，在实例化一个 defaultdict 的时候，需要给构造方法提供一个可调用对象，这个可调用对象会在 \_、_getitem\_\_ 碰到找不到的键的时候被调用，让 \_\_getitem\_\_ 返回某种默认值。 

- 具体还可以在看看书

### 3.4.2　特殊方法\_\_missing\_\_ 

- 所有的映射类型在处理找不到的键的时候(使用\_\_getitem\_\_查找键，会在哪儿找呢？)，都会牵扯到 \_\_missing\_\_方法。 

  

## 3.5　字典的变种 

- collections.OrderedDict: 根据添加键的顺序排序，而不是根据键进行排序。
- collections.ChainMap: 该类型可以容纳数个不同的映射对象 


- collections.Counter: 这个映射类型会给键准备一个整数计数器 


- colllections.UserDict: 这个类其实就是把标准 dict 用纯 Python 又实现了一遍， 让用户继承使用。



## 3.6　子类化UserDict 

- UserDict 并不是 dict 的子类 
- UserDict 有一个叫作 data 的属性，是 dict 的实例，这个属性实际上是 UserDict 最终存储数据的地方 。
- 如需使用，继续读书和查找相关资料



## 3.7　不可变映射类型 





## 3.8　集合论 

- “集”既指set，又指frozenst

### 3.8.1　集合字面量 

- 集合的字面量——{1}、{1,2}，但是空集必须是{}

- dis.dis（反汇编函数） 

### 3.8.2　集合推导

```python
>>> from unicodedata import name ➊
>>> {chr(i) for i in range(32, 256) if 'SIGN' in name(chr(i),'')} ➋
{'§', '=', '¢', '#', '¤', '<', '¥', 'μ', '×', '$', '¶', '£', '©',
'°', '+', '÷', '±', '>', '¬', '®', '%'}
# ➊ 从 unicodedata 模块里导入 name 函数，用以获取字符的名字。
# ➋ 把编码在 32~255 之间的字符的名字里有“SIGN”单词的挑出来，放到一个集合里。
```

### 3.8.3　集合的操作 

- 略



## 3.9 dict和set的背后

这一节将会回答以下几个问题。

- Python 里的 dict 和 set 的效率有多高？
- 为什么它们是无序的？
- 为什么并不是所有的 Python 对象都可以当作 dict 的键或 set 里的元素？
- 为什么 dict 的键和 set 元素的顺序是跟据它们被添加的次序而定的，以及为什么在映射对象的生命周期中，这个顺序并不是一成不变的？
- 为什么不应该在迭代循环 dict 或是 set 的同时往里添加元素？ 

### 3.9.1　一个关于效率的实验 



### 3.9.2　字典中的散列表 

- 散列表其实是一个稀疏数组（总是有空白元素的数组称为稀疏数组）。

- 在一般的数据结构教材中，散列表里的单元通常叫作表元（bucket）。 

- 在 dict 的散列表当中，每个键值对都占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。 
- 因为 Python 会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时候，原有的散列表会被复制到一个更大的空间里面。 



- 1. 散列值和相等性 

     - 内置的 hash() 方法可以用于所有的内置类型对象。如果是自定义对象调用 hash() 的话，实际上运行的是自定义的 \_\_hash\_\_。 
     - 果两个对象在比较的时候是相等的，那它们的散列值必须相等。eg.1==1.0, => hash(1) == hash(1.0)
     - 越是相似但不相等的对象，它们散列值的差别应该越大 

  2. 散列表算法 

     eg.为了获取 my_dict[search_key] 背后的值 

     - ython 首先会调用hash(search_key) 来计算 search_key 的**散列值**；

     - 把这个值最低的几位数字当作**偏移量**，在散列表里查找表元（具体取几位，得看当前散列表的大小）。 
     - 若找到的表元是空的，则抛出KeyError 异常。
     - 若不是空的，则表元里会有一对found_key:found_value。这时候 Python 会检验 search_key== found_key 是否为真，如果它们相等的话，就会返回found_value 
     - 如果 search_key 和 found_key 不匹配的话，这种情况称为**散列冲突**。



### 3.9.3 dict的实现及其导致的结果

- 使用散列表给 dict 带来的优势和限制 

  1. 键必须是可散列的 

     (1) 支持 hash() 函数，并且通过 \_\_hash\_\_() 方法所得到的散列值是不变的。

     (2) 支持通过 \__eq\_\_() 方法来检测相等性。

     (3) 若 a == b 为真，则 hash(a) == hash(b) 也为真。 

  2. 字典在内存上的开销巨大 

  3. 键查询很快 

     - 毕竟是哈希，用空间换了时间

  4. 键的次序取决于添加顺序 

     - 具体例子见书本(主要讲了虽然key一样，但是由于放置顺序不一样，有哈希冲突的话，会导致键不一样)

  5. 往字典里添加新键可能会改变已有键的顺序

     -  添加新的可以的时候，如果原有空间不够了，就会扩展空间，然后重新散射，会导致新的散射冲突

  


### 3.9.4 set的实现以及导致的结果

- set相当于一个没有值的dict，很多特性与上一节中的dict很相似
  - 集合里的元素必须是可散列的。
  - 集合很消耗内存。
  - 可以很高效地判断元素是否存在于某个集合。
  - 元素的次序取决于被添加到集合里的次序。
  - 往集合里添加元素，可能会改变集合里已有元素的次序 



# 参考

[instance和type的区别](<https://www.jianshu.com/p/1c7ca3954fb8>)

[PYTHON3基本数据类型（一、数字类型）](https://www.cnblogs.com/aiwanbuhui/p/7766352.html)

[关于Python中的字典(映射、哈希、散列)理解\](https://blog.csdn.net/lovebaby859450415/article/details/79620715)